%{
	
	#include <iostream>
	#include <stdlib.h>
	#include "output.hpp"
	using namespace std;
	

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
	
%}

%token    VOID 
%token    INT 
%token    BYTE 
%token    B 
%token    BOOL 

%token    TRUE 
%token    FALSE 
%token    RETURN 
%token    WHILE 
%token    BREAK 
%token    CONTINUE  
%token    SC 
%token    COMMA 
%token    ASSIGN
%token    ID 
%token    NUM 
%token    STRING

%nonassoc ID;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc BYTE;
%nonassoc BOOL;
&nonassoc NUM;
%nonassoc B;
%nonassoc OR;                // not sure
%nonassoc RELOPR;            // is RELOP == | != 
%left LPAREN;
%right RPAREN;
%left COMMA;
%left LBRACKET;
%right RBRACKET;             /// not sure about LBRACKET AND LBRACKET  should be treated as LBRACE/RBARACE or LPAREN/RPAREN
%right NOT;
%left AND;
%left RELOPL;               // is RELOP <= | >= | > | < should be left 
%left ADD;                  // add is +/-       /// splitted BINOP
%left MUL;                  // MUL is * or /

%%

Program:  Funcs
          {
			  output::printProductionRule(1);
		  }
		  
Funcs :  
		  {
		      output::printProductionRule(2);
		  } 	

		  | FuncDecl Funcs 
		  {
		      output::printProductionRule(3);
		  }
		  
FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 
		  {
		      output::printProductionRule(4);
		  }

RetType:  Type
          {
			  output::printProductionRule(5);
		  }
		  | VOID
		  {
			  output::printProductionRule(6);
		  }

Formals: 
		  {
		      output::printProductionRule(7);
		  }
		  | FormalsList
		  {
		      output::printProductionRule(8);	
		  }		

FormalsList:FormalDecl 
		  {
		      output::printProductionRule(9);
		  }
		  | FormalDecl COMMA FormalsList
		  {
		      output::printProductionRule(10);
		  }

FormalDecl: Type ID
		  {
		      output::printProductionRule(11);
		  }
		  
Statements: Statement
		  {
		      output::printProductionRule(12);
		  }
		  | Statements Statement	
		  {
		      output::printProductionRule(13);
		  }
Statement: LBRACE Statements RBRACE	
		  {
		      output::printProductionRule(14);
		  }
		  | Type ID SC	
		  {
		      output::printProductionRule(15);
		  }
		  | Type ID ASSIGN Exp SC	
		  {
		      output::printProductionRule(16);
		  }
		  | ID ASSIGN Exp SC	
		  {
		      output::printProductionRule(17);
		  }	
		  | Call SC
		  {
		      output::printProductionRule(18);
		  }
		  | RETURN SC	
		  {
		      output::printProductionRule(19);
		  }
		  | RETURN Exp SC
		  {
		      output::printProductionRule(20);
		  }
		  | IF LPAREN Exp RPAREN Statement 	
		  {
		      output::printProductionRule(21);
		  }
		  | IF LPAREN Exp RPAREN Statement ELSE Statement
		  {
		      output::printProductionRule(22);
		  }
		  | WHILE LPAREN Exp RPAREN Statement
		  {
		      output::printProductionRule(23);
		  }
		  | BREAK SC
		  {
		      output::printProductionRule(24);
		  }	
		  | CONTINUE SC
		  {
		      output::printProductionRule(25);
		  }
		  
Call:      ID LPAREN Explist RPAREN 
          {
			  printProductionRule(26);
		  }
          | ID LPAREN RPAREN 
		  {
			  printProductionRule(27);
		  }

Explist:    Exp 
          {
	          printProductionRule(28);
		  }
          | Exp COMMA Explist 
		  {
			  printProductionRule(29);
		  }

Type :      INT 
          {
			  printProductionRule(30);
		  }
          |  BYTE 
		  {
			  printProductionRule(31);
		  }
          | BOOL 
		  {
			  printProductionRule(32);
		  }
          | SET LBRACKET NUM DOTS NUM RBRACKET 
		  {
			  printProductionRule(33);
		  }

Exp:        LPAREN Exp RPAREN 
          {
			  printProductionRule(34);
		  }
          | Exp BINOP Exp 
		  {
			  printProductionRule(35);
		  }
          | ID 
		  {
			  printProductionRule(36);
		  }
          | Call 
		  {
			  printProductionRule(37);
		  }
          | NUM 
		  {
			  printProductionRule(38);
		  }
          | NUM B 
		  {
			  printProductionRule(39);
		  }
          | STRING 
		  {
			  printProductionRule(40);
		  }
          | TRUE 
		  {
			  printProductionRule(41);
		  }
          | FALSE 
		  {
			  printProductionRule(42);
		  }
          | NOT Exp 
		  {
			  printProductionRule(43);
		  }
          | Exp AND Exp 
		  {
			  printProductionRule(44);
		  }
          | Exp OR Exp 
		  {
			  printProductionRule(45);
		  }
          | Exp ADD Exp 
		  {
			  printProductionRule(46);
		  }
          | Exp MUL Exp 
		  {
			  printProductionRule(47);
		  }
          | LPAREN Type RPAREN Exp 
		  {
			  printProductionRule(48);
		  }
		  
%%

int main()
{
	yyparse();
}
		  
int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}
		  
	  
		  
		  
